<!doctype html>
<html lang="eng">

<head>
    <title>Task</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <link rel="stylesheet" href="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/jspsych.css?v=1682292823.928237">
    <link rel="shortcut icon" href="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/favicon.ico?v=1682292823.928726"/>
</head>

<body style="background-color:#7F7F7F">
    <script>
        // ################### DEFINE EXPERIMENT IDENTIFIERS HERE ###################
        // Important: for automated aws setup, the name of this html file should be {experiment_name}_{experiment_number}.html
        const experiment_name = "maggie_experiment";
        const experiment_number = 3; // CHANGE
        const aws_prefix = "magpeng1"; // Prefix for AWS service names on a shared account. Can be empty string "" if you don't want a prefix
        const num_test_trials = 40; // want 64 train, 20 test
        let condition_idx = null; // Will be set after trials are loaded
        let user_ip = null; 
        let user_email = null;
        const done_qualification_type_id = "3J1BANAN65L5FWD9QSUPU4J5WJ2EZA"; //CHANGE TO PROD
        const SANDBOX = false; //@@@@@@@@@@@@ CHANGE THIS @@@@@@@@@@@@@@@@@@@@@@ CHANGE THIS @@@@@@@@@@@@@@@ CHANGE THIS @@@@@@@@@@@@@@@
        const ASSIGN_QUALS_LAMBDA_API_GATEWAY_URL = "https://zdmhgtejk4.execute-api.us-east-1.amazonaws.com/prod/assign_quals";
        const MIN_WIDTH = 600;
        const MIN_HEIGHT = 600;
    </script>
</body>

<script>
    function getUrlParameters() {
        const params = new URLSearchParams(window.location.search);
        const output = {};
        for (const [key, value] of params.entries()) {
            output[key] = value;
        }
        return output;
    }
    const params = getUrlParameters();
    let platform = params.PLATFORM || null;
    const pid_from_url = params.PID || params.PROLIFIC_PID || null;
    const study_id_from_url = params.STUDY_ID || null;
    const trialset_id_from_url = params.TRIALSET_ID || null;
    let assignment_id_global = params.SESSION_ID || null;  
</script>

<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/jspsych.js?v=1682292823.9282172"></script>
<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-instructions.js?v=1682292823.935534"></script>
<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-preload.js?v=1682292823.935555"></script>
<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-html-keyboard-response.js?v=1682292823.935572"></script>
<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-survey-multi-choice.js?v=1682292823.935593"></script>
<!-- <script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-browser-check.js?v=1682292823.935612"></script> -->
<script src="https://morgan-study-misc.s3.amazonaws.com/custom_mturk_jspsych_plugin_browser_check.js?v=1.001"></script>
<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-html-button-response.js?v=1682292823.935626"></script>
<script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/external_javascript/jspsych/dist/plugin-fullscreen.js?v=1682292823.935638"></script>
<!-- <script src="https://s3.amazonaws.com/miljspsych/jspsych_writer/jspsych_overload/jspsych-psychophysics.js?v=1682292823.9356532"></script> -->
<script src="https://morgan-study-misc.s3.amazonaws.com/jspsych-psychophysics.js?v=1.015"></script>
<script src="https://morgan-study-misc.s3.amazonaws.com/jspsych-window-size-check.js?v=1.002"></script>
<script src="https://morgan-study-misc.s3.amazonaws.com/jspsych-my-virtual-chinrest.js?v=1.000"></script>
<script src="https://unpkg.com/@jspsych/plugin-survey-text@1.1.3"></script>

<script>
function _store_jspsych_cookie(trial_data) {
  CookieUtils.setCookie('jspsych-my-virtual-chinrest', JSON.stringify(trial_data), 7,)
}
</script>

<script>
<!-- common_javascript/milutils/session_nodes.js -->
function get_browser_check_node(){
    let return_message = '<p>We apologize for the inconvenience. Please press the "Return" button or close the tab/window to exit.</p>'
    return {
        timeline: [
            {
                type: jsPsychBrowserCheck,
                inclusion_function: (data) => {
                    return data.mobile === false
                },
                exclusion_message: (data) => {
                    if (data.mobile) {
                        return '<p>You must use a desktop/laptop computer to participate in this experiment.</p>' + return_message;
                    }
                },
            },
            {
                type: jsPsychBrowserCheck,
                inclusion_function: (data) => {
                    const os = data.os.toLowerCase();
                    return os.includes("windows") || os.includes("mac") || os.includes("linux") || os.includes("chrome");
                },
                exclusion_message: (data) => {
                    return `<p>Your operating system is not supported for this experiment. Please use a device with Windows, Mac, Linux, or Chrome OS.</p>` + return_message;
                },
            },
            {
                type: jsPsychBrowserCheck,
                minimum_width: MIN_WIDTH,
                minimum_height: MIN_HEIGHT,
                exclusion_message: (data) => {
                    return `<p>Your browser does not meet the technical requirements for this experiment. Please use a device with a larger screen.</p>` + return_message;
                }
            },
        ],
    };
}

function get_instructions_node(instructions_html_pages){


    function wrap_instructions_html(
        instructions_string_html,
    ) {

        let div = document.createElement("div");
        div.style['width'] = "auto";
        //div.style['maxWidth'] = "80%";
        div.style['margin'] = '0 auto'
        //div.style['padding'] = '10px'
        div.style['display'] = 'flex';
        div.style['align-items'] = 'center';
        div.style['flex-direction'] = 'column';
        div.style['font-size'] = '14px';
        //div.style['z-index'] = '-1';
        //div.style['font-family'] = '\'Helvetica Neue\', serif';
        div.style['text-align'] = 'left';
        div.style['color'] = '#4B4B4B';
        div.style['background-color'] = '#E4E4E4';
        div.style['border-radius'] = '8px';
        div.style['border-color'] = '#7F7F7F';
        div.style['border-style'] = 'solid';
        div.style['padding-right'] = '2%';
        div.style['padding-left'] = '2%';
        div.style['padding-bottom'] = '2%';

        let span = document.createElement('span');
        span.innerHTML = instructions_string_html;
        div.appendChild(span);
        return div.outerHTML;
    }

    let trial_seq = [];
    for (let i_page = 0; i_page < instructions_html_pages.length; i_page++) {
        let html_cur = wrap_instructions_html(
            instructions_html_pages[i_page],
        );

        let button_text;
        if (i_page < instructions_html_pages.length - 1) {
            button_text = `Next (${i_page + 1}/${instructions_html_pages.length})`;
        }
        else{
            button_text = 'Continue';
        }
        let cur_trial = {
                type: jsPsychHtmlButtonResponse,
                stimulus: html_cur,
                choices: function () {
                    if (jsPsych.turk.turkInfo().previewMode === true)
                        return ['In preview mode. Accept HIT to continue.']
                    else
                        return [button_text]
                },
            }
        trial_seq.push(cur_trial);
    }

    let instructions_timeline = {
        timeline: trial_seq,
        loop_function: function (data) {
            if (jsPsych.turk.turkInfo().previewMode === true) {
                return true;
            } else {
                return false;
            }
        }
    }

    return instructions_timeline;

}
</script>

<script>
function get_mailing_list_node() {
    return {
        type: jsPsychSurveyText,
        questions: [{'name': 'user_email', prompt:'<b>CLICK BELOW TO SUBMIT YOUR WORK.</b><br>'}],
        button_label: 'SUBMIT',
    }
}

function redirect(url) {
    try {
        window.location.href = url;
    } catch (e) {
        window.location.replace(url);
    }
    
    // Fallback if the above methods fail
    setTimeout(function() {
        window.location = url;
    }, 100);
}

<!-- common_javascript/milutils/turk.js -->
function get_turk_submission_node(trialset_id) {  //(get_submission_data_function) {
    // The get_session_data_function should return a JSON object of the data you'd wish to submit to Turk.
    return {
        type: jsPsychHtmlButtonResponse,
        stimulus: '<h1>Click below to submit your work.</h1>',
        choices: ['Submit'],
        trial_duration: 0, // Optional: wait some number of seconds before autosubmitting
        on_finish: function () {
            const turkInfo = jsPsych.turk.turkInfo();
            let data = jsPsych.data.get().json() //get_submission_data_function()
            let datastring = JSON.stringify(data);
            let dataobject = {
                'datastring': datastring,
                'workerId': turkInfo.workerId,
                'assignmentId': turkInfo.assignmentId,
                'trialset_id': trialset_id,
                'bonus_usd': MTS_TASK_GLOBALS.BONUS_USD_EARNED,
                'turkInfo': turkInfo,
            }
            jsPsych.turk.submitToTurk(dataobject);

            // Check if the user entered their email
            try {
                const last_data = jsPsych.data.get().last(10).values();
                last_data.forEach(function(entry) {
                    if (entry.trial_type === 'survey-text' && entry.response && entry.response.user_email) {
                        const isWhitespaceString = str => !str.replace(/\s/g, '').length
                        if (!isWhitespaceString(entry.response.user_email.toString())) {
                            const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                            if (emailPattern.test(entry.response.user_email.toString())) {
                                user_email = entry.response.user_email.toString()
                            } else {
                                user_email = "invalid email: " + entry.response.user_email.toString()
                            }
                        } 
                    }
                });
            } catch (error) {
                console.warn("Error occurred while checking for email:", error);
            }

            session_metadata_lambda(experiment_name, experiment_number, aws_prefix, session_metadata_api_url, platform, assignment_id_global, data, MTS_TASK_GLOBALS.BONUS_USD_EARNED, null, "store_session_data")
                .then(response => {
                    if (response.redirectUrl) {

                        // Fallback message with link in case the participant is not redirected automatically
                        const container = document.createElement('div');
                        container.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background-color: #f0f0f0; padding: 20px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1);';
                        const message = document.createElement('p');
                        message.textContent = 'If you are not automatically redirected, please click the link below:';
                        container.appendChild(message);
                        const link = document.createElement('a');
                        link.href = response.redirectUrl.toString();
                        link.textContent = 'Continue to next page';
                        link.style.cssText = 'display: inline-block; margin-top: 10px; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px;';
                        container.appendChild(link);
                        document.body.appendChild(container);
                        
                        // Attempt redirect
                        redirect(response.redirectUrl);
                    } else {
                        console.log("No redirect URL provided");
                    }
                })
                .catch(error => {
                    console.error("Error when storing final session data:", error);
                });

            if (turkInfo.outsideTurk === true && platform == null) {
                console.log(data)
                jsPsych.data.displayData('JSON');
            }
        },
    };
}
</script>

<script>
<!-- common_javascript/milutils/cookie_utils.js -->
class CookieUtils {

    static setCookie(cname, cvalue, exdays) {
        const d = new Date();
        cvalue = encodeURIComponent(cvalue);
        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
        let expires = "expires=" + d.toUTCString();
        let cookie_set = cname + "=" + cvalue
        let suffix = 'SameSite=None; Secure'
        document.cookie = cookie_set + ";" + expires + ";path=/" + ";" + suffix;
    }

    static getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) === 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }
}
</script>

<script>
<!-- common_javascript/milutils/action_listeners.js -->
function get_mouse_listener(
    get_active_regions_function,
    on_valid_response_function,
) {
    /*
    get_active_regions_function: Returns an array of Objects, each of which defines a different active region. Each active region is an object with the following properties:
        - x. A callable which returns the x-centroid of the active region, in coordinates of the target node to which the listener belongs.
        - y. A callable which returns the y-centroid of the active region.
        - r. A callable which returns the radius of the circle.
    on_valid_response_function: A function that is called when a valid response is made. The function is called with the following arguments:
        - data:
            {
                responseX: int,
                responseY: int,
                choices_made: [bool, bool, ...],
                rel_timestamp_response:int
            }
     */

    function check_if_inside_circle(x, y, xc, yc, r) {
        var dxs = Math.pow(x - xc, 2);
        var dys = Math.pow(y - yc, 2);
        return (dxs + dys) <= Math.pow(r, 2);
    }


    function clicked_func(event) {
        let rel_t = performance.now();
        let userX_px = event.offsetX;
        let userY_px = event.offsetY;

        let choice_was_selected = false;
        let data = {
            responseX: userX_px,
            responseY: userY_px,
            rel_timestamp_response: rel_t,
            choices_made:[],
            i_choice: null,
        }

        let active_regions = get_active_regions_function();
        let nactive_regions = active_regions.length;
        for (let i_region = 0; i_region < nactive_regions; i_region++) {

            let region_cur = active_regions[i_region];
            let xc = region_cur['x'];
            let yc = region_cur['y'];
            let r = region_cur['r'];

            let is_inside = check_if_inside_circle(
                userX_px,
                userY_px,
                xc,
                yc,
                r,
            );

            data['choices_made'].push(is_inside)
            if (is_inside === true) {
                // todo - handle multiple simultaneous choices
                data['i_choice'] = i_region;
            }
            choice_was_selected = choice_was_selected || is_inside;
        }

        if (choice_was_selected === true) {
            on_valid_response_function(data)
        }
    }

    return clicked_func
}


</script>

<script>
<!-- common_javascript/milutils/canvas_text.js -->
function renderCenteredWrappedText(context, text, x, y, max_width_px, max_characters_per_line, lineHeight, font, color) {
  font = font || "Arial";
  context.fillStyle = color || "black";
  context.textAlign = "center";
  context.textBaseline = "middle";

    // Estimate the font size
    let max_width_px_per_character = max_width_px / max_characters_per_line;
    let font_size_px = max_width_px_per_character * 1.7 || 12;

    font_size_px = Math.max(Math.round(font_size_px), 2);
    context.font = font_size_px.toString() + "px " + font;

  // Split text by words
  var words = text.split(' ');
  var line = '';
  var lines = [];

  for(var n = 0; n < words.length; n++) {
    var testLine = line + words[n] + ' ';
    var metrics = context.measureText(testLine);
    var testWidth = metrics.width;
    if (testWidth > max_width_px && n > 0) {
      lines.push(line);
      line = words[n] + ' ';
    } else {
      line = testLine;
    }
  }
  lines.push(line);

  // Calculate the starting y position
  var startingY = y - (lines.length - 1) * lineHeight / 2;

  // Draw each line
  for (var i = 0; i < lines.length; i++) {
    context.fillText(lines[i], x, startingY + i * lineHeight);
  }
}

</script>



<script>
    let MTS_TASK_GLOBALS = new class {
    constructor() {
        /*
        Get default viewing parameters (legacy choices)
        Legacy choice is that 17.5% of the smallest screen dimension corresponds to 6 degrees of visual angle.
         */

        let reference_degrees_default = 6;
        let reference_proportion_default = 0.175;
        let screen_s = Math.min(window.screen.height, window.screen.width); // Min of height and width
        let viewing_distance_pixels_default = (reference_proportion_default * screen_s / 2) / Math.tan((reference_degrees_default / 2) * Math.PI / 180)

        function infer_canvas_size_legacy() {
            // Present the canvases at 70% of the smallest screen dimension
            let [screen_height, screen_width] = [window.screen.height, window.screen.width]
            let screen_margin = 0.3;
            return Math.round(Math.min(screen_height, screen_width)) * (1 - screen_margin);
        }

        this.BACKGROUND_COLOR = '#7F7F7F';
        this.VIEWING_DISTANCE_PIXELS = viewing_distance_pixels_default;

        //this.CANVAS_HEIGHT_PIXELS = get_size()//infer_canvas_size_legacy();
        //this.CANVAS_WIDTH_PIXELS = get_size(); //infer_canvas_size_legacy();
        this.CALIBRATED = false;

        /*
        HUD parameters for tracking
         */
        this.BONUS_USD_EARNED = 0;
        this.TRIALS_COMPLETED = 0;
        this.NTRIALS = 0;
    }

    _get_size() {
        let [h, w] = [0.90 * window.innerHeight, 0.95 * window.innerWidth];
        return Math.round(Math.min(h, w))

    }

    get_canvas_height_pixels() {
        return this._get_size();
    }

    get_canvas_width_pixels() {
        return this._get_size();
    }

    calibrate_viewing_distance(viewing_distance_pixels) {
        if (typeof viewing_distance_pixels === 'number') {
            if (viewing_distance_pixels > 0) {
                this.VIEWING_DISTANCE_PIXELS = viewing_distance_pixels;
                this.CALIBRATED = true;
            }
        }
    }

    stimulus_degrees_to_pixels(degrees) {
        /*
        Convert degrees of visual angle to pixels on the screen, assuming stimulus is
        presented at normal angle.
         */

        let radians = degrees * Math.PI / 180;
        let pixels = 2 * this.VIEWING_DISTANCE_PIXELS * Math.tan(radians / 2);

        // Safety checks
        // Underflow
        let min_pixels = 0;
        let max_pixels = Math.min(this.get_canvas_height_pixels(), this.get_canvas_width_pixels())
        if (pixels < 0) {
            pixels = min_pixels;
        }
        // Overflow
        if (pixels > max_pixels) {
            pixels = max_pixels
        }

        return pixels
    }
}()


class MTS_Trial_Nodes {

    static get_timeline() {

        let fixation_node = MTS_Trial_Nodes.get_fixation_node()
        let blank_screen = MTS_Trial_Nodes.get_blank_screen_node(
            () => {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels()
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels()
            },
            0,
        );
        let stimulus_choice_node = MTS_Trial_Nodes.get_nway_stimulus_choice_node();
        let feedback_node = MTS_Trial_Nodes.get_feedback_node();

        let conditional_fixation_node = {
            timeline: [fixation_node, blank_screen],
            conditional_function: function() {
                let show_fixation = jsPsych.timelineVariable('show_fixation');
                if (show_fixation === undefined) {
                    show_fixation = false; //Default false unless overrided (for backwards-compatibility)
                }
                return show_fixation
            }
        }

        let conditional_feedback_node = {
            timeline: [blank_screen, feedback_node],
            conditional_function: function() {
                let show_feedback = jsPsych.timelineVariable('show_feedback');
                if (show_feedback === undefined) {
                    show_feedback = true; //Default true unless overrided (for backwards-compatibility)
                }
                return show_feedback
            }
        }

        let intertrial_node = MTS_Trial_Nodes.get_intertrial_node();

        let window_size_check_node = {
            type: jsPsychWindowSizeCheck,
            minimum_width: MIN_WIDTH,
            minimum_height: MIN_HEIGHT,
            on_finish: function (data) {
                jsPsych.getDisplayElement().innerHTML = '';
            }
        }

        let timeline = [
            conditional_fixation_node,
            stimulus_choice_node,
            conditional_feedback_node,
            intertrial_node,
            window_size_check_node,
        ]
        return timeline
    }

    static get_blank_screen_node(
        background_color,
        canvas_width_px,
        canvas_height_px,
        duration_msec
    ) {
        let blank_screen = {
            type: jsPsychPsychophysics,
            stimuli: [],
            background_color: background_color,
            response_type: 'key',
            response_ends_trial: true, // from the trial start (ms)
            trial_duration: duration_msec, // One frame
            canvas_width: canvas_width_px,
            canvas_height: canvas_height_px,
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: true,
            remain_canvas: false, // If true, the canvas is not cleared at the end of the trial.
            show_start_time: 0, // from the trial start (ms)
            show_end_time: undefined, // from the trial start (ms)
        }
        return blank_screen;
    }


    static get_feedback_node() {

        let get_reinforcement = function () {
            let last_trial_data = jsPsych.data.get().last(2).values()[0];
            let trial_outcome = last_trial_data['trial_outcome']
            let perf = trial_outcome['perf']

            let reinforcement = 0;

            if (perf > 0) {
                reinforcement = 1;
            } else {
                reinforcement = -1;
            }
            return reinforcement
        }

        let get_feedback_duration_msec = function () {
            let reinforcement = get_reinforcement();
            if (reinforcement > 0) {
                return jsPsych.timelineVariable('reward_duration_msec');
            } else if (reinforcement < 0) {
                return jsPsych.timelineVariable('incorrect_duration_msec');
            } else {
                return 0;
            }
        }

        let get_feedback_lockout_duration_msec = function () {
            let reinforcement = get_reinforcement();
            if (reinforcement > 0) {
                return jsPsych.timelineVariable('correct_feedback_lockout_duration_msec');
            } else if (reinforcement < 0) {
                return jsPsych.timelineVariable('incorrect_feedback_lockout_duration_msec');
            } else {
                return 0;
            }
        }

        let get_feedback_stimulus = function () {

            let positive_feedback_object;
            let negative_feedback_object;

            let feedback_correct_url = jsPsych.timelineVariable('feedback_correct_url', true);
            let feedback_incorrect_url = jsPsych.timelineVariable('feedback_incorrect_url', true);

            let canvas_width = MTS_TASK_GLOBALS.get_canvas_width_pixels();
            let canvas_height = MTS_TASK_GLOBALS.get_canvas_height_pixels();

            let min_canvas_dim = Math.min(canvas_width, canvas_height);

            let get_feedback_size = function () {
                //return MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('stimulus_width_degrees', true))/3;
                let stimulus_width_px = Math.min(MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('stimulus_width_degrees', true)), 0.7*min_canvas_dim);
                return parseInt(0.9*(min_canvas_dim - stimulus_width_px)/2)
            }

            if (feedback_correct_url !== undefined) {
                positive_feedback_object = {
                    obj_type: 'image', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    file: feedback_correct_url,
                    image_width: get_feedback_size, // of the rectangle
                    //line_color: '#ffffff',
                    fill_color: '#62c63b',
                    show_start_time: 0, // from the trial start (ms)
                }
            } else {
                // Fallback
                positive_feedback_object = {
                    obj_type: 'rect', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    width: get_feedback_size,
                    height: get_feedback_size,
                    //line_color: '#ffffff',
                    fill_color: '#62c63b',
                    show_start_time: 0, // from the trial start (ms)
                }
            }

            if (feedback_incorrect_url !== undefined) {
                negative_feedback_object = {
                    obj_type: 'image', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    file: feedback_incorrect_url,
                    image_width: get_feedback_size,
                    //line_color: '#ffffff',
                    fill_color: '#af1111',
                    show_start_time: 0, // from the trial start (ms)
                }
            } else {
                // Fallback
                negative_feedback_object = {
                    obj_type: 'rect', // means a rectangle
                    startX: 'center', // location in the canvas
                    startY: 'center',
                    width: get_feedback_size,
                    height: get_feedback_size,
                    fill_color: '#000000',
                    show_start_time: 0 // from the trial start (ms)
                }
            }

            const neutral_feedback_object = {
                obj_type: 'rect', // means a rectangle
                startX: 'center', // location in the canvas
                startY: 'center',
                width: 0, // of the rectangle
                height: 0,
                fill_color: function () {
                    return MTS_TASK_GLOBALS.BACKGROUND_COLOR
                },
                show_start_time: 0 // from the trial start (ms)
            }

            let feedback_objects = [];

            // Original stimulus image
            let stimulus_image_url = jsPsych.timelineVariable('stimulus_image_url', true);
            let stimulus_width_px = Math.min(MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('stimulus_width_degrees', true)), 0.7*min_canvas_dim);
            let stimulus_height_px = stimulus_width_px // TODO need to implement properly for non-square images
            let stimulus_object = {
                obj_type: 'image',
                startX: 'center',
                startY: 'center', // Adjust this to leave room for feedback and text below
                file: stimulus_image_url,
                image_width: stimulus_width_px,
            };
            feedback_objects.push(stimulus_object);

            // Determine reinforcement and accordingly set feedback and text
            let reinforcement = get_reinforcement();
            let last_trial_data = jsPsych.data.get().last(2).values()[0];
            let trial_outcome = last_trial_data['trial_outcome'];
            let stimulus_name = trial_outcome['stimulus_name'];
            let choice_name = trial_outcome['choice_name'];

            let feedback_stimulus;
            let feedback_text_line1;
            let feedback_text_line2;
            let feedback_text_color;
            let feedback_text_font;
            let min_feedback_duration;
            if (reinforcement > 0) {
                // Positive feedback
                feedback_stimulus = positive_feedback_object; // Assuming positive_feedback_object is defined similarly to your original code
                //feedback_text = `Correct!\nThe answer is: ${stimulus_name}`;
                feedback_text_line1 = `Your answer: ${choice_name}`
                feedback_text_line2 = stimulus_name // `Correct answer: ${stimulus_name}`
                feedback_text_color = '#5df542'
                feedback_text_font = "bold 24px Arial"
                min_feedback_duration = jsPsych.timelineVariable('correct_feedback_lockout_duration_msec')
            } else if (reinforcement < 0) {
                // Negative feedback
                feedback_stimulus = negative_feedback_object; // Assuming negative_feedback_object is defined similarly to your original code
                //feedback_text = `Incorrect.\nThe answer is: ${stimulus_name}.\nYou answered: ${choice_name}`;
                feedback_text_line1 = `Your answer:    ${choice_name}`
                feedback_text_line2 = stimulus_name //`Correct answer: ${stimulus_name}`
                feedback_text_color = '#ff4f4f'
                feedback_text_font = "24px Arial"
                min_feedback_duration = jsPsych.timelineVariable('incorrect_feedback_lockout_duration_msec')
            }

            feedback_stimulus.startY = (canvas_height/2 - stimulus_height_px/2)/2; 
            feedback_objects.push(feedback_stimulus);

            feedback_objects.push({
                obj_type: 'text',
                content: feedback_text_line2,
                startX: 'center',
                startY: (canvas_height/2 + stimulus_height_px/2) + parseInt(0.25*(canvas_height/2 - stimulus_height_px/2)),
                text_color: 'white',
                font: "bold 48px Arial",
                text_space: 20,
            });

            // Instruction text ("Press spacebar to continue")
            let instruction_text_object = {
                obj_type: 'text',
                content: "Press spacebar to continue",
                startX: 'center',
                startY: (canvas_height/2 + stimulus_height_px/2) + parseInt((0.75)*(canvas_height/2 - stimulus_height_px/2)),
                text_color: 'white',
                show_start_time: min_feedback_duration,
                font: "24px Arial",
                text_space: 20,
            };
            feedback_objects.push(instruction_text_object);

            return feedback_objects;
        }

        let feedback_screen = {
            type: jsPsychPsychophysics,
            stimuli: get_feedback_stimulus,
            background_color: function () {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            canvas_width: function () {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels()
            },
            canvas_height: function () {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels()
            },
            response_type: 'key',
            choices: [' '],
            response_start_time: get_feedback_lockout_duration_msec,
            trial_duration: get_feedback_duration_msec,
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: true,
            remain_canvas: false, // If true, the canvas is not cleared at the end of the trial.
            on_finish: function (data) {
                jsPsych.getCurrentTrial().funcs.dispose();
            }
        }
        return feedback_screen
    }

    static get_fixation_node() {

        let get_startX_px = function () {
            let px = MTS_TASK_GLOBALS.get_canvas_width_pixels() * 0.5 // Center
            return px
        };

        let get_startY_px = function () {
            let px = MTS_TASK_GLOBALS.get_canvas_height_pixels() * 0.5
            return px
        };

        let get_radius_px = function () {
            let px = MTS_TASK_GLOBALS.get_canvas_width_pixels() * 0.02 // Legacy choice
            return px
        }

        function get_fixation_active_region() {
            return {
                obj_type: 'circle',
                startX: get_startX_px,
                startY: get_startY_px,
                origin_center: false,
                radius: get_radius_px,
                line_color: 'white',
                fill_color: 'white',
                show_start_time: 0
            }
        }

        const fixation_cross = {
            obj_type: 'cross',
            startX: 'center',
            startY: 'center',
            line_length: function () {
                let px = MTS_TASK_GLOBALS.get_canvas_width_pixels() * 0.02
                px = Math.max(px, 10) // Legacy choice
                return px
            },
            line_color: 'black',
            show_start_time: 0
        }

        function get_active_regions() {
            return [{
                x: get_startX_px(),
                y: get_startY_px(),
                r: get_radius_px(),
            }]
        }

        let fixation_clicked_func = get_mouse_listener(
            get_active_regions,
            function (data) {
                document.body.style.cursor = 'none';
                jsPsych.finishTrial(data)
            },
        )

        // Trial initiation screen
        return {
            type: jsPsychPsychophysics,
            stimuli: function () {
                return [get_fixation_active_region(), fixation_cross]
            },
            response_type: 'mouse',
            response_start_time: 0,
            response_ends_trial: false,
            mouse_down_func: fixation_clicked_func,
            background_color: function () {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            canvas_width: function () {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels();
            },
            canvas_height: function () {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels();
            },
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: true,
            remain_canvas: false, // If true, the canvas is not cleared at the end of the trial.
        }
    }


    static get_nway_stimulus_choice_node() {

        let t0_choices_drawn;
        let stimulus_width_px;
        let choice_width_px_default;
        let choice_width_px
        let trial_monitor_width_px = window.screen.width;
        let trial_monitor_height_px = window.screen.height;
        let cursor_hidden;
        let choices_drawn = false;
        let stimulus_drawn = false;

        function get_stimulus_object(
            stimulus_image_url,
            image_width_px,
            stimulus_duration_msec,
            leave_stimulus_on,
        ) {

            let show_end_time;
            if (leave_stimulus_on === true) {
                show_end_time = null
            } else {
                show_end_time = stimulus_duration_msec
            }
            let stimulus_object = {
                obj_type: 'image',
                startX: 'center',
                startY: 'center',
                origin_center: true,
                file: stimulus_image_url,
                image_width: image_width_px,
                show_start_time: 0,
                show_end_time: show_end_time,
            };

            return stimulus_object;
        }


        function get_choice_stimuli(
            choice_image_urls,
            radius_px,
            image_width_px,
            choice_onset_msec,
        ) {
            let nchoices = choice_image_urls.length;
            let xy = get_choice_locations(nchoices, radius_px)

            let choice_objects = []
            for (let i_choice = 0; i_choice < nchoices; i_choice++) {
                let choice_i_image_url = choice_image_urls[i_choice];

                let choice_i_object = {
                    obj_type: 'image',
                    startX: xy[0][i_choice], // location in the canvas
                    startY: xy[1][i_choice],
                    origin_center: true,
                    file: choice_i_image_url,
                    image_width: image_width_px,
                    show_start_time: choice_onset_msec, // from the trial start (ms)
                    show_end_time: undefined, // from the trial start (ms)
                }

                choice_objects.push(choice_i_object)
            }

            return choice_objects
        }


        function get_choice_locations(nway, radius_px) {
            // Returns choice centroids in x and y coordinates, [x_seq, y_seq]
            // Ensures the centroids are equally spaced around a circle of r = radius
            // And that the choices are arranged in a way that is horizontally symmetric.

            let is_even = nway % 2 === 0
            let theta_0 = 0
            if (is_even === false) {
                theta_0 = Math.PI / 2; // Set the first choice to be theta = -90
            }
            else if (nway === 2) {
                theta_0 = Math.PI
            }
            // let theta_0 = 2*Math.PI*Math.random() // This version creates a random (not necessarily symmetric) rotation of the ring.

            let theta_seq = []
            for (let i = 0; i < nway; i++) {
                let theta_i = 2 * Math.PI * i / nway + theta_0;
                theta_seq.push(theta_i)
            }

            let x_seq = theta_seq.map(theta_i => radius_px * Math.cos(theta_i))
            let y_seq = theta_seq.map(theta_i => radius_px * Math.sin(theta_i))
            return [x_seq, y_seq]
        }

        function get_prompt_draw(
            query_string,
            canvas_width_px,
            canvas_height_px,
            min_y_bound,
            prompt_onset_msec,
        ) {

            let size = canvas_width_px;
            let max_text_width = size * 0.75
            let line_height_factor = 1.4;
            let font = 'Arial'
            let max_characters_per_line = 50;
            let horizontal_alignment = 'center';
            let vertical_alignment = 'bottom';


            let draw_func = function (stimulus, canvas, context, elapsedTime, sumOfStep) {
                let xleft = MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2 - max_text_width / 2;
                let xright = MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2 + max_text_width / 2;
                let ytop = 0;
                let ybottom = min_y_bound;
                renderCenteredWrappedText(
                    context, 
                    query_string, 
                    MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2, 
                    MTS_TASK_GLOBALS.get_canvas_width_pixels() / 2, 
                    max_text_width, 
                    max_characters_per_line,
                    10, 
                    font, 
                    'white'
                )
            }

            return {
                obj_type: 'manual',
                startX: 0, // location in the canvas
                startY: 0,
                origin_center: true,
                drawFunc: draw_func,
                show_start_time: prompt_onset_msec, // from the trial start (ms)
                show_end_time: undefined // from the trial start (ms)
            }
        }


        function assemble_stimuli() {
            // Timeline variables
            let query_string = jsPsych.timelineVariable('query_string');
            let canvas_width_px = MTS_TASK_GLOBALS.get_canvas_width_pixels();
            let canvas_height_px = MTS_TASK_GLOBALS.get_canvas_height_pixels();
            let min_canvas_dim = Math.min(MTS_TASK_GLOBALS.get_canvas_width_pixels(), MTS_TASK_GLOBALS.get_canvas_height_pixels());
            stimulus_width_px = Math.min(MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('stimulus_width_degrees', true)), 0.7*min_canvas_dim);
            choice_width_px_default = MTS_TASK_GLOBALS.stimulus_degrees_to_pixels(jsPsych.timelineVariable('choice_width_degrees_default', true));
            let stimulus_image_url = jsPsych.timelineVariable('stimulus_image_url');
            let leave_stimulus_on = jsPsych.timelineVariable('keep_stimulus_on');
            let choice_names = jsPsych.timelineVariable('choice_names')
            let choice_image_urls = jsPsych.timelineVariable('choice_image_urls');
            let stimulus_duration_msec = jsPsych.timelineVariable('stimulus_duration_msec');
            let post_stimulus_delay_msec = jsPsych.timelineVariable('post_stimulus_delay_duration_msec');

            // Get stimulus object
            let stimulus_object = get_stimulus_object(
                stimulus_image_url,
                stimulus_width_px,
                stimulus_duration_msec,
                leave_stimulus_on
            )

            let stimulus_canary_object = {
                obj_type: 'manual',
                show_start_time: 0, // from the trial start (ms)
                show_end_time: undefined, // from the trial start (ms)
                drawFunc: function (stimulus, canvas, context, elapsedTime, sumOfStep) {
                    if (stimulus_drawn === false) {
                        stimulus_width_px = stimulus_width_px;
                        trial_monitor_width_px = window.screen.width;
                        trial_monitor_height_px = window.screen.height;
                        stimulus_drawn = true;
                    }
                }
            }

            // Get choice objects
            //let choice_radius_px = parseInt((min_canvas_dim - 1.05*choice_width_px_default)/2.5);
            let choice_radius_px = parseInt(stimulus_width_px/2 + (min_canvas_dim/2 - stimulus_width_px/2)/2)
            let n_choices = choice_image_urls.length
            //choice_width_px = parseInt(Math.sin(Math.PI/n_choices)*2*choice_radius_px)
            choice_width_px = parseInt(Math.min(Math.sin(Math.PI/n_choices)*2*choice_radius_px, 0.9*(min_canvas_dim - stimulus_width_px)/2))
            if (choice_width_px > choice_width_px_default) {
                choice_width_px = choice_width_px_default
            }
            let choice_onset_msec = post_stimulus_delay_msec + stimulus_duration_msec;
            let choice_objects = get_choice_stimuli(
                choice_image_urls,
                choice_radius_px,
                choice_width_px,
                choice_onset_msec,
            )

            // Get canary object for getting draw time of the choice stimuli
            let choice_canary_object = {
                obj_type: 'manual',
                show_start_time: choice_onset_msec, // from the trial start (ms)
                show_end_time: undefined, // from the trial start (ms)
                drawFunc: function (stimulus, canvas, context, elapsedTime, sumOfStep) {
                    if (choices_drawn === false) {
                        t0_choices_drawn = performance.now();
                        choices_drawn = true;

                    }
                }
            }

            // Get text prompt
            let xy = get_choice_locations(choice_image_urls.length, choice_radius_px)
            let min_y_bound = canvas_height_px / 2
            let prompt_object = get_prompt_draw(
                query_string,
                canvas_width_px,
                canvas_height_px,
                min_y_bound,
                choice_onset_msec,
            )

            // Assemble all objects
            let stim_array = choice_objects.concat([stimulus_object, stimulus_canary_object, choice_canary_object])
            return stim_array
        }

        function on_valid_response(data) {
            let pre_choice_lockout_delay_duration_msec = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec', true)
            let rel_timestamp_response = data['rel_timestamp_response'];
            let reaction_time_msec = rel_timestamp_response - t0_choices_drawn;

            if (reaction_time_msec < pre_choice_lockout_delay_duration_msec) {
                // Ignore clicks that occur before the pre-choice lockout delay
                return
            }

            // Log processed data
            data['reaction_time_msec'] = reaction_time_msec

            // CHeck whether mouse click occurred within a valid timeframe
            jsPsych.finishTrial(data)
        }


        let get_active_regions = function () {

            let stim_array_cur = jsPsych.getCurrentTrial().stim_array;
            let nway = jsPsych.timelineVariable('choice_image_urls', true).length;

            let active_regions = []
            for (let i_choice = 0; i_choice < nway; i_choice++) {
                let choice_object = stim_array_cur[i_choice];
                let choice_radius_px = choice_width_px / 2 || choice_object['radius'];

                let choice_startX_px = choice_object['startX'];
                let choice_startY_px = choice_object['startY'];
                active_regions.push(
                    {
                        'x': choice_startX_px,
                        'y': choice_startY_px,
                        'r': choice_radius_px,
                    }
                )
            }

            return active_regions
        }

        let choice_clicked_func = get_mouse_listener(
            get_active_regions,
            on_valid_response,
        )

        let screen_node = {
            type: jsPsychPsychophysics,
            stimuli: assemble_stimuli,
            background_color: function () {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            response_type: function() {
                console.log("keypress_fj_response:")
                console.log(jsPsych.timelineVariable('keypress_fj_response'))
                if (jsPsych.timelineVariable('keypress_fj_response')){
                    return 'key'
                } else {
                    return 'mouse'
                }
            },
            response_ends_trial: function() {
                if (jsPsych.timelineVariable('keypress_fj_response')){
                    return true
                } else {
                    return false
                }
            },
            mouse_down_func: null,
            choices: function() {
                if (jsPsych.timelineVariable('keypress_fj_response')){
                    return ['f', 'j']
                } else {
                    return undefined
                }
            },
            response_start_time: jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec'),
            trial_duration: function () {
                let stimulus_duration_msec = jsPsych.timelineVariable('stimulus_duration_msec');
                let post_stimulus_delay_msec = jsPsych.timelineVariable('post_stimulus_delay_duration_msec');
                let pre_choice_lockout_delay_duration_msec = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec');
                let choice_duration_msec = jsPsych.timelineVariable('choice_duration_msec') || undefined;
                let max_trial_duration = stimulus_duration_msec + post_stimulus_delay_msec + pre_choice_lockout_delay_duration_msec + choice_duration_msec || undefined;
                return max_trial_duration
            },
            canvas_width: function () {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels();
            },
            canvas_height: function () {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels();
            },
            canvas_offsetX: 0,
            canvas_offsetY: 0,
            clear_canvas: true,
            remain_canvas: false,
            show_start_time: 0,
            show_end_time: undefined,
            on_start: function (trial) {
                if (!jsPsych.timelineVariable('keypress_fj_response')) {
                    trial.mouse_down_func = choice_clicked_func;
                }

                let stimulus_duration_msec = jsPsych.timelineVariable('stimulus_duration_msec', true);
                let post_stimulus_delay_msec = jsPsych.timelineVariable('post_stimulus_delay_duration_msec');
                let pre_choice_lockout_delay_duration_msec = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec');

                let timeout_msec = stimulus_duration_msec + post_stimulus_delay_msec + pre_choice_lockout_delay_duration_msec || 200;
                timeout_msec = timeout_msec + 100;
                setTimeout(
                    () => {
                        document.body.style.cursor = 'auto'
                    }, timeout_msec
                );
            },
            on_finish: function (data) {
                let rel_timestamp_response = performance.now()
                let reaction_time_msec = rel_timestamp_response - t0_choices_drawn;

                // Increment progressbar
                let cur_progress_bar_value = jsPsych.getProgressBarCompleted();
                jsPsych.setProgressBar(cur_progress_bar_value + (1 / MTS_TASK_GLOBALS.NTRIALS));

                // Log processed data
                stimulus_drawn = false;
                choices_drawn = false;
                // Evaluate choice if there is a correct choice
                let i_correct_choice = jsPsych.timelineVariable('i_correct_choice');
                let no_correct_choice_exists = i_correct_choice === null || typeof i_correct_choice === 'undefined';
                let correct_choice_exists = !no_correct_choice_exists;
                let gt;
                let i_choice;

                let fj_response = jsPsych.timelineVariable('keypress_fj_response');

                if (fj_response) { // For keyboard (f/j) responses
                    i_choice = data['response'] === 'f' ? 0 : (data['response'] === 'j' ? 1 : data['response']);
                    if (correct_choice_exists === false) {
                        gt = null;
                    } else {
                        gt = i_choice === i_correct_choice ? 1 : 0;
                    }
                } else { // For mouse responses
                    if (correct_choice_exists === false) {
                        gt = null;
                    } else {
                        if (!data['choices_made'] || i_correct_choice >= data['choices_made'].length) {
                            console.log('choices_made is null, or undefined, or i_correct_choice is out of bounds.')
                            gt = null
                        } else {
                            gt = data['choices_made'][i_correct_choice] === true ? 1 : 0;
                        }
                    }
                    i_choice = data['i_choice']
                }

                let trial_outcome = {}
                let tstart = performance.timing.navigationStart;
                let tstart_trial = data['time_elapsed'] // Round to the millisecond
                trial_outcome['timestamp_start'] = (tstart + tstart_trial) / 1000 // Unix timestamp
                trial_outcome['choices_made'] = data['choices_made']
                trial_outcome['i_choice'] = i_choice
                
                trial_outcome['i_correct_choice'] = i_correct_choice;
                trial_outcome['rel_timestamp_response'] = rel_timestamp_response
                trial_outcome['perf'] = gt; // Needed for feedback screen
                trial_outcome['reaction_time_msec'] = reaction_time_msec;

                delete data['choices_made']
                delete data['rel_timestamp_response']
                delete data['reaction_time_msec']
                delete data['i_choice']

                trial_outcome['trial_type'] = jsPsych.timelineVariable('trial_type', true)

                trial_outcome['block'] = jsPsych.timelineVariable('block', true)
                trial_outcome['stimulus_image_url'] = jsPsych.timelineVariable('stimulus_image_url', true)
                trial_outcome['class'] = jsPsych.timelineVariable('class', true)
                trial_outcome['choice_names'] = jsPsych.timelineVariable('choice_names', true)
                trial_outcome['choice_image_urls'] = jsPsych.timelineVariable('choice_image_urls', true)
                trial_outcome['query_string'] = jsPsych.timelineVariable('query_string', true)
                trial_outcome['stimulus_duration_msec'] = jsPsych.timelineVariable('stimulus_duration_msec', true)
                trial_outcome['post_stimulus_delay_duration_msec'] = jsPsych.timelineVariable('post_stimulus_delay_duration_msec', true)
                trial_outcome['pre_choice_lockout_delay_duration_msec'] = jsPsych.timelineVariable('pre_choice_lockout_delay_duration_msec', true)
                trial_outcome['choice_duration_msec'] = jsPsych.timelineVariable('choice_duration_msec', true)
                trial_outcome['keep_stimulus_on'] = jsPsych.timelineVariable('keep_stimulus_on', true)
                trial_outcome['trial_number'] = MTS_TASK_GLOBALS.TRIALS_COMPLETED;
                trial_outcome['stimulus_width_px'] = stimulus_width_px
                trial_outcome['choice_width_px'] = choice_width_px
                trial_outcome['monitor_width_px'] = trial_monitor_width_px;
                trial_outcome['monitor_height_px'] = trial_monitor_height_px;
                
                trial_outcome['stimulus_name'] = trial_outcome['choice_names'][trial_outcome['i_correct_choice']]  
                trial_outcome['choice_name'] = trial_outcome['choice_names'][trial_outcome['i_choice']]

                trial_outcome['condition_idx'] = jsPsych.timelineVariable('condition_idx', true)

                // Set condition_idx (to be collected as metadata). 'Inconsistent' if more than one different value is provided. 
                if (condition_idx === null) {
                    condition_idx = trial_outcome['condition_idx']
                    jsPsych.data.addProperties({'condition_idx': condition_idx})
                } else if (condition_idx != trial_outcome['condition_idx']) {
                    condition_idx = 'INCONSISTENT'
                }

                let bonus_usd_if_correct = jsPsych.timelineVariable('bonus_usd_if_correct', true) || 0;
                trial_outcome['bonus_usd_if_correct'] = bonus_usd_if_correct;

                data['trial_outcome'] = trial_outcome
                MTS_TASK_GLOBALS.TRIALS_COMPLETED += 1;
                if (correct_choice_exists === true) {
                    if (gt === 1) {
                        if (trial_outcome['trial_type'] != "repeat_stimulus" && trial_outcome['trial_type'] != "calibration") {
                            MTS_TASK_GLOBALS.BONUS_USD_EARNED += bonus_usd_if_correct;
                        }
                    }
                }

                jsPsych.getCurrentTrial().funcs.dispose();
            }
        }

        return screen_node
    }


    static get_intertrial_node() {

        return MTS_Trial_Nodes.get_blank_screen_node(
            () => {
                return MTS_TASK_GLOBALS.BACKGROUND_COLOR
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_width_pixels()
            },
            () => {
                return MTS_TASK_GLOBALS.get_canvas_height_pixels()
            },
            jsPsych.timelineVariable('intertrial_delay_duration_msec'),
        )
    }
}

function get_nway_afc_trials(trial_sequence, session_settings) {

    MTS_TASK_GLOBALS.NTRIALS = trial_sequence.length;
    let instructions_node = get_instructions_node(session_settings['instructions_html'])

    let mts_nodes = [];
    let image_urls_to_load = [];

    // Sample random integer
    const refresh_param = Math.random().toString()//
    function refresh_url(url_string){
        // Encourage browser to refresh image
        let url = new URL(url_string);
        url.searchParams.set('x', refresh_param);
        let url_string_refreshed = url.toString()
        return url_string_refreshed
    }

    let show_test_instructions = false

    for (let i = 0; i < trial_sequence.length; i++) {

        let timeline_cur = MTS_Trial_Nodes.get_timeline();
        let timeline_variables_cur = trial_sequence[i];

        // If we're transitioning to the test block, show test instructions
        if (timeline_variables_cur['show_test_instructions'] && !show_test_instructions) {
            let test_instructions_node = get_instructions_node([session_settings['test_instructions_html']])
            mts_nodes.push(test_instructions_node)
        }
        show_test_instructions = timeline_variables_cur['show_test_instructions']

        let stimulus_image_url = refresh_url(timeline_variables_cur['stimulus_image_url']);
        let choice_image_urls = timeline_variables_cur['choice_image_urls'].map(refresh_url);
        let feedback_correct_url = refresh_url(timeline_variables_cur['feedback_correct_url']);
        let feedback_incorrect_url = refresh_url(timeline_variables_cur['feedback_incorrect_url']);

        timeline_variables_cur['stimulus_image_url'] = stimulus_image_url;
        timeline_variables_cur['choice_image_urls'] = choice_image_urls;
        timeline_variables_cur['feedback_correct_url'] = feedback_correct_url;
        timeline_variables_cur['feedback_incorrect_url'] = feedback_incorrect_url;

        image_urls_to_load.push(stimulus_image_url);
        image_urls_to_load.push(feedback_correct_url);
        image_urls_to_load.push(feedback_incorrect_url);
        image_urls_to_load = image_urls_to_load.concat(choice_image_urls);

        mts_nodes.push({
                timeline: timeline_cur,
                timeline_variables: [timeline_variables_cur],
            }
        )
    }

    // The following function checks the image URLs for testing purposes, to be run ONLY if outside mechanical turk. 
    function preloadImagesAndIdentifyErrors(imageUrls, onComplete) {
        let loadedCount = 0;
        const errors = [];
        imageUrls.forEach((url) => {
            const img = new Image();
            img.onload = () => {
                loadedCount++;
                if (loadedCount === imageUrls.length) {
                    onComplete(errors);
                }
            };
            img.onerror = () => {
                console.error('Failed to load:', url);
                errors.push(url);
                loadedCount++;
                if (loadedCount === imageUrls.length) {
                    onComplete(errors);
                }
            };
            img.src = url;
        });
    }

    if (jsPsych.turk.turkInfo().outsideTurk) {
        preloadImagesAndIdentifyErrors(image_urls_to_load, (errors) => {
            if (errors.length > 0) {
                console.log('Failed URLs:', errors);
            } else {
                console.log('All images loaded successfully.');
            }
        });
    }

    let task_preload = {
        type: jsPsychPreload,
        auto_preload: false,
        show_progress_bar: true,
        message: 'Loading images...',
        images: image_urls_to_load,
        on_start: function () {
            document.body.style.backgroundColor = '#7F7F7F';
        },
        on_finish: function () {
            console.log('Done preloading MTS assets.')
            jsPsych.setProgressBar(0.005);
        }
    }

    // Setup fullscreen

    let fullscreen_node = {
        timeline: [
            {
                type: jsPsychFullscreen,
            }
        ],
        conditional_function: function () {
            let run = session_settings['force_fullscreen'] === true
            return run;
        },
    }

    let monitor_calibration_node = {
        timeline: [
            {
                type: jsPsychMyVirtualChinrest,
                credit_card_reps: 1,
                blindspot_reps: 2,
                credit_card_image_path: 'https://miljspsych.s3.amazonaws.com/resources/assets/images/card.png',
                credit_card_init_size: function () {
                    let loaded_cookie = CookieUtils.getCookie('external-my-virtual-chinrest')
                    let initial_credit_card_size_pixels = 400; // Default

                    if (loaded_cookie.length > 0) {
                        loaded_cookie = JSON.parse(loaded_cookie)
                        console.log('Loaded cookie:', loaded_cookie)
                        let final_item_width_px = loaded_cookie['outputs']['average_reported_item_width_px']
                        if (typeof final_item_width_px === 'number') {
                            initial_credit_card_size_pixels = Math.min(1000, Math.max(40, final_item_width_px))
                        }
                    }
                    return initial_credit_card_size_pixels
                },
                on_finish: function (data) {
                    console.log('Monitor calibration done. Result:', data)
                    _store_jspsych_cookie(data)
                    console.log(data)
                    let viewing_distance_px = data['outputs']['viewing_distance_px']
                    MTS_TASK_GLOBALS.calibrate_viewing_distance(viewing_distance_px);
                }
            },
        ],
        conditional_function: function () {
            let run = session_settings['calibrate_monitor'] === true
            return run;
        },
    }
    let timeline = [fullscreen_node, instructions_node, task_preload, monitor_calibration_node].concat(mts_nodes)
    let finish_node = {
        type: jsPsychHtmlButtonResponse,
        choices: ['Press to continue'],
        trial_duration: 10000,
        stimulus: function () {
            const turkInfo = jsPsych.turk.turkInfo()
            if (turkInfo.outsideTurk === false && turkInfo.previewMode === false) {
                let qualification_type_ids = [done_qualification_type_id]
                assign_quals_lambda_wrapper(qualification_type_ids, SANDBOX);
            }

            let pt_accuracy = (MTS_TASK_GLOBALS.BONUS_USD_EARNED*100 / num_test_trials)*100 // For now, we add 0.01 to BONUS_USD_EARNED for each correct, qualifying trial

            if (pt_accuracy < 75) {
                MTS_TASK_GLOBALS.BONUS_USD_EARNED = 0
                return 'Thank you for your work!'
            } else if (pt_accuracy >= 75 && pt_accuracy < 85) {
                MTS_TASK_GLOBALS.BONUS_USD_EARNED = 5.00
            } else if (pt_accuracy >= 85 && pt_accuracy < 95) {
                MTS_TASK_GLOBALS.BONUS_USD_EARNED = 10.00
            } else if (pt_accuracy >= 95) {
                MTS_TASK_GLOBALS.BONUS_USD_EARNED = 20.00
            } else {
                MTS_TASK_GLOBALS.BONUS_USD_EARNED = 0
                return 'Thank you for your work. Your accuracy was ' + (pt_accuracy).toFixed(0).toString() + '%. There was an internal error in calculating the bonus: please write you accuracy down and contact the researcher.'
            }

            return 'Thank you for your work!';
        },
        on_finish: function(data) {
            data.response = MTS_TASK_GLOBALS.BONUS_USD_EARNED;
        }
    }

    timeline.push(finish_node)
    let block_timeline = {
        'timeline': timeline,
    }
    return block_timeline
}
</script>

<script>
async function getUserIP() {
    try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return data.ip;
    } catch (error) {
        console.error('Error fetching the IP address:', error);
        return null;
    }
}

function session_metadata_lambda(experiment_name, experiment_number, aws_prefix, api_gateway_url, platform = null, assignment_id = null, datastring = null, bonus_usd = null, trialset_id = null, request_purpose = null, max_retries = 3, initial_delay = 1000) {
    const turkInfo = jsPsych.turk.turkInfo();

    function makeRequest(retryCount) {
        return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        var response = JSON.parse(xhr.responseText);
                        resolve(response);
                    } else {
                        reject('Request failed with status: ' + xhr.status);
                    }
                }
            };

            xhr.open("POST", api_gateway_url, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.setRequestHeader("Accept", "application/json");

            let payload = {
                experiment_name: experiment_name,
                experiment_number: experiment_number,
                aws_prefix: aws_prefix,
            };

            if (turkInfo.outsideTurk === false && turkInfo.previewMode === false) {
                payload.worker_id = turkInfo.workerId;
                payload.hit_id = turkInfo.hitId;
                payload.assignment_id = turkInfo.assignmentId;
            }
            
            if (pid_from_url !== null) {
                payload.worker_id = pid_from_url; // Overrides a values set by turk, if present
            }
            if (study_id_from_url !== null) {
                payload.hit_id = study_id_from_url; // Overrides a values set by turk, if present
            }

            if (assignment_id !== null) {
                payload.assignment_id = assignment_id;
            }
            else if (assignment_id_global !== null) { // Overrides value set by turk, if present
                payload.assignment_id = assignment_id_global;
            }

            if (datastring !== null) {
                payload.datastring = datastring;
            }
            if (bonus_usd !== null) {
                payload.bonus_usd = bonus_usd.toString();
            }
            if (platform !== null) {
                payload.platform = platform;
            }
            if (trialset_id !== null) {
                payload.trialset_id = trialset_id
            }
            if (condition_idx !== null) { // Note that this is a global variable defined near the top of the script
                payload.condition_idx = condition_idx
            }
            if (user_ip != null) {
                payload.user_ip = user_ip
            }
            if (user_email !== null) {
                payload.user_email = user_email
            }
            if (request_purpose !== null) {
                payload.request_purpose = request_purpose
            }

            xhr.send(JSON.stringify(payload));
        });
    }

    function retryWithExponentialBackoff(retryCount) {
        return makeRequest(retryCount).catch(error => {
            if (retryCount < max_retries) {
                const delay = initial_delay * Math.pow(2, retryCount);
                console.log(`Attempt ${retryCount + 1} failed. Retrying in ${delay}ms...`);
                return new Promise(resolve => setTimeout(resolve, delay))
                    .then(() => retryWithExponentialBackoff(retryCount + 1));
            } else {
                throw error;
            }
        });
    }

    return retryWithExponentialBackoff(0);
}

function assign_quals_lambda(qualification_type_ids, sandbox) {
    const turkInfo = jsPsych.turk.turkInfo();
    return new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if (xhr.status == 200) {
                    var response = JSON.parse(xhr.responseText);
                    resolve(response);
                } else {
                    reject('Request failed with status: ' + xhr.status);
                }
            }
        };

        xhr.open("POST", ASSIGN_QUALS_LAMBDA_API_GATEWAY_URL, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("Accept", "application/json");
        
        if (turkInfo.outsideTurk === false && turkInfo.previewMode === false) {
            xhr.send(JSON.stringify({
                worker_id: turkInfo.workerId,
                qualification_type_ids: qualification_type_ids,
                score: parseInt(MTS_TASK_GLOBALS.BONUS_USD_EARNED*100),
                sandbox: sandbox
            }));
        }
    });
}

async function assign_quals_lambda_wrapper(qualification_type_ids, sandbox) {
    console.log("assigning quals")
    qual_lambda_response = await assign_quals_lambda(qualification_type_ids, SANDBOX);
    console.log(qual_lambda_response)
}

function load_script(url) {
    return new Promise((resolve, reject) => {
        var script = document.createElement('script');
        script.src = `${url}?v=${new Date().getTime()}`;
        script.onload = () => resolve(script);
        script.onerror = () => reject(new Error(`Script load error for ${url}`));
        document.head.appendChild(script);
    });
}
</script>

<script>
    async function run_experiment(experiment_name, experiment_number, aws_prefix) {
        try {
            const turkInfo = jsPsych.turk.turkInfo();
            let user_in_preview_mode = turkInfo.previewMode;
            
            bucket_url = 'https://' + `${aws_prefix}-${experiment_name.replace(/_/g, "-").toLowerCase()}-${experiment_number}` + '.s3.amazonaws.com';

            user_ip = await getUserIP();

            await load_script(bucket_url + "/aws_constants.js"); // session_metadata_api_url defined inside

            let trialset_id;
            if (platform == 'test') {
                assignment_id_global = 'test_assignment'
                if (trialset_id_from_url !== null) {
                    trialset_id = trialset_id_from_url
                }
                else {
                    trialset_id = 0
                }
            }
            else {
                if (turkInfo.outsideTurk === false && turkInfo.previewMode === false) {
                    platform = 'mturk'
                }
                const response = await session_metadata_lambda(experiment_name, experiment_number, aws_prefix, session_metadata_api_url, platform, null, null, null, trialset_id_from_url, "initialize_session_metadata");
                trialset_id = response.trialset_id;
                assignment_id_global = response.assignment_id;
            }

            jsPsych.data.addProperties({
                'experiment_name': experiment_name,
                'experiment_number': experiment_number,
                'aws_prefix': aws_prefix,
                'assignment_id': assignment_id_global,
                'trialset_id': trialset_id,
                'platform': platform,
                'request_purpose': 'store_trial_data'
            })

            // Load the trialset as a js file in s3
            let trialset_url = new URL(bucket_url + '/trialsets/' + `${experiment_name}_${experiment_number}_trials_${trialset_id}.js`)
            trialset_url.searchParams.set('x', Math.random().toString()) // Encourage browser to refresh
            trialset_url_string = trialset_url.toString()
            await load_script(trialset_url_string);

            let experiment_timeline = get_nway_afc_trials(trial_variables, session_settings);

            jsPsych.run([
                preview_gate,
                browser_check_node,
                experiment_timeline,
                get_mailing_list_node(),
                get_turk_submission_node(trialset_id)
            ],)

        } catch (error) {
            console.error('Error:', error);
        }
    }
</script>

<script>

    let jsPsych = initJsPsych(
        {
            show_progress_bar: true,
            auto_update_progress_bar: false,
            message_progress_bar: 'Progress',
        }
    );

    let session_settings = {
    "instructions_html": [
        "<ul> <li>Thank you for participating in this experiment!</li> <li>This task involves learning to distinguish between two different EEGs of motor imagery tasks (e.g., EEG taken while imagining moving your left vs. right hand).</li> <li> Your participation will help us find better ways to teach medical students to identify and diagnose diseases more accurately from images. </li> <li>Some trials may be hard. We cannot guarantee that it is possible to choose accurately in all cases.</li> <li>We reserve the right to end the experiment at any time.</li> <li>If you encounter a bug (e.g., the task freezing), please contact us and let us know.</li> <li>By clicking \"Continue\" on the next page, you voluntarily consent to be a participant in our experiment.</li> </ul>",
        "<ul> <b>INSTRUCTIONS</b> <li>Click one of the round buttons to make a choice on each image.</li> <li> Please try your best to learn by trial and error.</li> <li>You must make each choice within <b>20 seconds</b></li> <li>Do your best, and good luck!</li> </ul>"
    ],
    "test_instructions_html": "\n <ul>\n    <li>Thank you for completing the training phase of the experiment!</li>\n       <li>Press \"Continue\" to begin the test phase.</li>\n  <li>During the test, you will <b>not</b> receive feedback, but <text style=\"color:green; font-style:oblique\">You will earn a $5.00 bonus if your accuracy is above 75%, or $10.00 above 85%, or $20.00 above 95%.</text></li>\n      </ul>",
    "calibrate_monitor": false,
    "force_fullscreen": false
    };


    let browser_check_node = get_browser_check_node();

    // Run the timeline
    let preview_gate = {
        timeline: [{
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<h1 style="color:red">PREVIEW MODE</h1> Please accept the HIT to continue.',
            choices: [' '],
            on_start: function () {
                console.log('At preview gate.')
            },
        }],
        conditional_function: function () {
            return jsPsych.turk.turkInfo().previewMode || platform === null
        },
    };

    run_experiment(experiment_name, experiment_number, aws_prefix)
</script>


</html>

